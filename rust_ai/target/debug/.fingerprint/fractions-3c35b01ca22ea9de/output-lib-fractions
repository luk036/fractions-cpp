{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1088,"byte_end":1106,"line_start":39,"line_end":39,"column_start":32,"column_end":50,"is_primary":true,"text":[{"text":"        let mantissa = (bits & ((1i64 << 52) - 1)) as i128 | (1i128 << 52);","highlight_start":32,"highlight_end":50}],"label":"expected `u64`, found `i64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:39:32\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m39\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let mantissa = (bits & ((1i64 << 52) - 1)) as i128 | (1i128 << 52);\n   \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `u64`, found `i64`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no implementation for `u64 & i64`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":1086,"byte_end":1087,"line_start":39,"line_end":39,"column_start":30,"column_end":31,"is_primary":true,"text":[{"text":"        let mantissa = (bits & ((1i64 << 52) - 1)) as i128 | (1i128 << 52);","highlight_start":30,"highlight_end":31}],"label":"no implementation for `u64 & i64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `BitAnd<i64>` is not implemented for `u64`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `BitAnd<Rhs>`:\n  `&u64` implements `BitAnd<u64>`\n  `&u64` implements `BitAnd`\n  `u64` implements `BitAnd<&u64>`\n  `u64` implements `BitAnd`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: no implementation for `u64 & i64`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:39:30\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m39\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let mantissa = (bits & ((1i64 << 52) - 1)) as i128 | (1i128 << 52);\n   \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mno implementation for `u64 & i64`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the trait `BitAnd<i64>` is not implemented for `u64`\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `BitAnd<Rhs>`:\n             `&u64` implements `BitAnd<u64>`\n             `&u64` implements `BitAnd`\n             `u64` implements `BitAnd<&u64>`\n             `u64` implements `BitAnd`\n\n"}
{"$message_type":"diagnostic","message":"cannot add `&Fraction` to `Fraction`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":8175,"byte_end":8181,"line_start":303,"line_end":303,"column_start":18,"column_end":24,"is_primary":true,"text":[{"text":"        self.add(&other)","highlight_start":18,"highlight_end":24}],"label":"no implementation for `Fraction + &Fraction`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\lib.rs","byte_start":8171,"byte_end":8174,"line_start":303,"line_end":303,"column_start":14,"column_end":17,"is_primary":false,"text":[{"text":"        self.add(&other)","highlight_start":14,"highlight_end":17}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `std::ops::Add<&Fraction>` is not implemented for `Fraction`","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":155,"byte_end":174,"line_start":8,"line_end":8,"column_start":1,"column_end":20,"is_primary":true,"text":[{"text":"pub struct Fraction {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following other types implement trait `std::ops::Add<Rhs>`:\n  `Fraction` implements `std::ops::Add<i128>`\n  `Fraction` implements `std::ops::Add`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: cannot add `&Fraction` to `Fraction`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:303:18\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m303\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         self.add(&other)\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mno implementation for `Fraction + &Fraction`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `std::ops::Add<&Fraction>` is not implemented for `Fraction`\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:8:1\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct Fraction {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `std::ops::Add<Rhs>`:\n              `Fraction` implements `std::ops::Add<i128>`\n              `Fraction` implements `std::ops::Add`\n\n"}
{"$message_type":"diagnostic","message":"cannot subtract `&Fraction` from `Fraction`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":8636,"byte_end":8642,"line_start":327,"line_end":327,"column_start":18,"column_end":24,"is_primary":true,"text":[{"text":"        self.sub(&other)","highlight_start":18,"highlight_end":24}],"label":"no implementation for `Fraction - &Fraction`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\lib.rs","byte_start":8632,"byte_end":8635,"line_start":327,"line_end":327,"column_start":14,"column_end":17,"is_primary":false,"text":[{"text":"        self.sub(&other)","highlight_start":14,"highlight_end":17}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `std::ops::Sub<&Fraction>` is not implemented for `Fraction`","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":155,"byte_end":174,"line_start":8,"line_end":8,"column_start":1,"column_end":20,"is_primary":true,"text":[{"text":"pub struct Fraction {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following other types implement trait `std::ops::Sub<Rhs>`:\n  `Fraction` implements `std::ops::Sub<i128>`\n  `Fraction` implements `std::ops::Sub`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: cannot subtract `&Fraction` from `Fraction`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:327:18\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m327\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         self.sub(&other)\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mno implementation for `Fraction - &Fraction`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `std::ops::Sub<&Fraction>` is not implemented for `Fraction`\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:8:1\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct Fraction {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `Fraction` implements `std::ops::Sub<i128>`\n              `Fraction` implements `std::ops::Sub`\n\n"}
{"$message_type":"diagnostic","message":"cannot multiply `Fraction` by `&Fraction`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":9097,"byte_end":9103,"line_start":351,"line_end":351,"column_start":18,"column_end":24,"is_primary":true,"text":[{"text":"        self.mul(&other)","highlight_start":18,"highlight_end":24}],"label":"no implementation for `Fraction * &Fraction`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\lib.rs","byte_start":9093,"byte_end":9096,"line_start":351,"line_end":351,"column_start":14,"column_end":17,"is_primary":false,"text":[{"text":"        self.mul(&other)","highlight_start":14,"highlight_end":17}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `std::ops::Mul<&Fraction>` is not implemented for `Fraction`","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":155,"byte_end":174,"line_start":8,"line_end":8,"column_start":1,"column_end":20,"is_primary":true,"text":[{"text":"pub struct Fraction {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following other types implement trait `std::ops::Mul<Rhs>`:\n  `Fraction` implements `std::ops::Mul<i128>`\n  `Fraction` implements `std::ops::Mul`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: cannot multiply `Fraction` by `&Fraction`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:351:18\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m351\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         self.mul(&other)\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mno implementation for `Fraction * &Fraction`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `std::ops::Mul<&Fraction>` is not implemented for `Fraction`\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:8:1\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct Fraction {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `Fraction` implements `std::ops::Mul<i128>`\n              `Fraction` implements `std::ops::Mul`\n\n"}
{"$message_type":"diagnostic","message":"cannot divide `Fraction` by `&Fraction`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":9574,"byte_end":9580,"line_start":375,"line_end":375,"column_start":18,"column_end":24,"is_primary":true,"text":[{"text":"        self.div(&other)","highlight_start":18,"highlight_end":24}],"label":"no implementation for `Fraction / &Fraction`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\lib.rs","byte_start":9570,"byte_end":9573,"line_start":375,"line_end":375,"column_start":14,"column_end":17,"is_primary":false,"text":[{"text":"        self.div(&other)","highlight_start":14,"highlight_end":17}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `std::ops::Div<&Fraction>` is not implemented for `Fraction`","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":155,"byte_end":174,"line_start":8,"line_end":8,"column_start":1,"column_end":20,"is_primary":true,"text":[{"text":"pub struct Fraction {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following other types implement trait `std::ops::Div<Rhs>`:\n  `Fraction` implements `std::ops::Div<i128>`\n  `Fraction` implements `std::ops::Div`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: cannot divide `Fraction` by `&Fraction`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:375:18\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m375\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         self.div(&other)\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mno implementation for `Fraction / &Fraction`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `std::ops::Div<&Fraction>` is not implemented for `Fraction`\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:8:1\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct Fraction {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `std::ops::Div<Rhs>`:\n              `Fraction` implements `std::ops::Div<i128>`\n              `Fraction` implements `std::ops::Div`\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 6 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: aborting due to 6 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0308.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mSome errors have detailed explanations: E0277, E0308.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
